Always use bun as the package manager instead of npm or yarn.

When suggesting package installations, always use `bun add` instead of `npm install` or `yarn add`.
When suggesting running scripts, always use `bun run` instead of `npm run` or `yarn run`.
When suggesting dev commands, use `bun dev` instead of `npm run dev` or `yarn dev`.

Examples:
- Use `bun add package-name` instead of `npm install package-name`
- Use `bun add -D package-name` instead of `npm install -D package-name`
- Use `bun run build` instead of `npm run build`
- Use `bun dev` instead of `npm run dev` 

## Git Commit Message Conventions

### Commit Message Format
Follow conventional commit format: `type: brief description`

### Commit Types
- `feat`: New feature or functionality
- `fix`: Bug fix
- `refactor`: Code refactoring without functional changes
- `style`: Formatting, missing semicolons, etc (no code change)
- `docs`: Documentation changes
- `test`: Adding or updating tests
- `chore`: Maintenance tasks, dependencies, build config
- `perf`: Performance improvements
- `ci`: CI/CD pipeline changes

### Commit Message Guidelines
- Use imperative mood: "add feature" not "added feature"
- Keep title under 50 characters
- Capitalize first letter of description
- No period at the end of title
- Include bullet points for multiple changes
- Add "Breaking Changes:" section if applicable
- Be concise but descriptive

### Example Commit Messages
```bash
feat: integrate React Query with SSR for Home page data fetching

fix: resolve toast notifications not staying open on errors

refactor: extract common layout wrapper to reduce code duplication

chore: update dependencies and add React Query DevTools

docs: add React Query integration guide to README
```

## React Query Integration Best Practices

### Naming Conventions
- Avoid variable names, types, or query keys that start with "use" as they can be confused with React hooks
- Use concise, clear names without redundant prefixes
- Examples:
  - âœ… `ProfileData` instead of `UserProfileData`
  - âœ… `getProfile()` instead of `getUserProfile()`
  - âœ… `['profile', 'data']` instead of `['user-profile', 'profile']`
  - âŒ Avoid `user-profile` in query keys (looks like a hook name)

### Data Fetching Architecture
- Follow TanStack Query Advanced SSR guide for server-side prefetching
- Use HydrationBoundary for optimal performance with prefetched data
- Server actions should throw errors instead of swallowing them
- Pass detailed error info to frontend for debugging in production

### Error Handling Strategy
- Show skeleton UI for both `(isLoading || error)` states
- Use toast notifications for error feedback (non-intrusive)
- Log detailed errors to frontend console with `console.error('ðŸ”´ ...')`
- Avoid dedicated error screens - keep UI stable
- Error toasts should always stay open with `duration: Infinity`

### React Query Error Handling
- **Mutations**: Use `onError` callback for automatic error handling
- **Queries**: Manually handle errors with `useEffect` and toast notifications
- **DRY principle**: Parse error once, call toast once - avoid duplication in try/catch blocks
- Always provide user feedback for failed operations

### Error Handling Pattern (DRY)
```typescript
// âœ… DRY Error Handling Pattern
const handleError = (error: Error, operation: string) => {
  let errorMessage = 'An unexpected error occurred'
  let debugInfo = error.message

  try {
    const errorData = JSON.parse(error.message)
    errorMessage = errorData.message || errorMessage
    debugInfo = errorData.debug
  } catch {
    // Use default message for non-JSON errors
  }

  console.error(`ðŸ”´ ${operation} error:`, debugInfo)
  toast.error(`Failed to ${operation}`, {
    description: errorMessage,
    duration: Infinity,
    action: { label: 'Retry', onClick: () => retryAction() }
  })
}

// Usage in mutations (automatic)
const mutation = useMutation({
  mutationFn: updateData,
  onError: (error) => handleError(error, 'update data')
})

// Usage in queries (manual with useEffect)
const { error } = useQuery({ ... })
useEffect(() => {
  if (error) handleError(error, 'load data')
}, [error])
```

### Type Safety & Organization
- Use Prisma-generated types with `Prisma.CompanionGetPayload<>` 
- Place types in existing `src/types/` directory structure
- Server action files with `'use server'` can only export async functions
- Separate types/constants into different files

### Code Quality Guidelines
- Don't modify component styling unless explicitly requested
- Follow existing project folder structure and conventions
- Use existing UI components (shadcn/ui) for consistency
- Avoid over-engineering - prefer simple direct implementations

### Server Actions Structure
```typescript
// âœ… Proper error handling in server actions
catch (error) {
  throw new Error(JSON.stringify({
    message: 'User-friendly message',
    debug: {
      originalError: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString()
    }
  }))
}
```

### React Query Key Conventions
- Always use simple string arrays for query keys: `['profile', 'usage']`
- Avoid complex query key factory functions - they add unnecessary complexity
- Use hierarchical structure: `['resource', 'type']` or `['resource', 'type', 'id']`
- Keep keys consistent between server-side prefetching and client-side hooks
- Server components should use the same string arrays as client hooks

### Query Key Examples
```typescript
// âœ… Simple and consistent
queryKey: ['profile', 'data']
queryKey: ['profile', 'usage'] 
queryKey: ['companions', 'list']
queryKey: ['companions', 'detail', companionId]

// âŒ Avoid complex factories
const queryKeys = {
  profile: {
    data: () => ['profile', 'data'],
    usage: () => ['profile', 'usage']
  }
}
``` 

## Forms Best Practices

### Form Architecture
- Use React Hook Form + Zod + shadcn/ui Form components pattern
- Create Zod schemas in `src/lib/schemas/` directory
- Implement both client-side and server-side validation using the same schema
- Use React Query for form submission when API integration is needed

### Form Schema Structure
```typescript
// src/lib/schemas/example.ts
import * as z from "zod"

export const exampleFormSchema = z.object({
  field: z
    .string()
    .min(2, "Field must be at least 2 characters")
    .max(30, "Field must not exceed 30 characters")
    .optional()
    .or(z.literal(""))
})

export type ExampleFormData = z.infer<typeof exampleFormSchema>
```

### Form Component Pattern
```typescript
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { exampleFormSchema, type ExampleFormData } from '@/lib/schemas/example'
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form'

const ExampleForm = () => {
  const form = useForm<ExampleFormData>({
    resolver: zodResolver(exampleFormSchema),
    defaultValues: { field: '' }
  })

  const onSubmit = async (data: ExampleFormData) => {
    // Handle form submission
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        <FormField
          control={form.control}
          name="field"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Field Label</FormLabel>
              <FormControl>
                <Input placeholder="Enter value" {...field} value={field.value || ''} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <Button type="submit" disabled={form.formState.isPending}>
          Submit
        </Button>
      </form>
    </Form>
  )
}
```

### Server Action Validation
```typescript
// src/lib/actions/example.ts
import { exampleFormSchema } from '@/lib/schemas/example'

export async function updateExample(data: ExampleFormData) {
  // Validate input data with Zod schema
  const validationResult = exampleFormSchema.safeParse(data)
  
  if (!validationResult.success) {
    throw new Error(JSON.stringify({
      message: 'Invalid input data',
      debug: {
        validationErrors: validationResult.error.flatten().fieldErrors,
        providedData: data,
        timestamp: new Date().toISOString()
      }
    }))
  }

  const validatedData = validationResult.data
  // Process validated data...
}
```

### Form Guidelines
- Always use the same Zod schema for both client and server validation
- Handle empty strings appropriately (convert to null for database storage)
- Use `form.formState.isDirty` for enabling/disabling save buttons
- Implement proper loading states with `isPending` from mutations
- Use `form.reset()` to reset form state after successful submissions
- Include proper error handling with structured error messages
- Use `Textarea` for multi-line text inputs instead of `Input`
- Add appropriate `placeholder` text for better UX

### Server Actions Structure
```typescript
// âœ… Proper error handling in server actions
catch (error) {
  throw new Error(JSON.stringify({
    message: 'User-friendly message',
    debug: {
      originalError: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString()
    }
  }))
}
``` 